---
title: "Hands-on session 3: Single-cell Data Preparation and Clustering in R"
author: "Ángeles Arzalluz-Luque"
date: "`r Sys.Date()`"
output:
  BiocStyle::html_document:
    toc: true
    css: ../Resources/style.css
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

In this session, we will reproduce some of the same analyses presented during 
Hands On Sessions 1 and 2 using the R programming language. This will include:

- Creation of Seurat and SingleCellExperiment objects to store single-cell data.
- Data visualization using dimensionality reduction techniques.
- Quality control of the data.
- Normalization and feature selection.
- Clustering of cells into cell types.

This tutorial is based on the following resources:

- [Seurat guided clustering tutorial](https://satijalab.org/seurat/articles/pbmc3k_tutorial.html)
- [Seurat cell cycle scoring vignette](https://satijalab.org/seurat/articles/cell_cycle_vignette.html)
- [Babraham Bioinformatics training resources](https://www.bioinformatics.babraham.ac.uk/training/10XRNASeq/seurat_workflow.html)


## Required packages

```{r, "Load Library", eval=T, message=FALSE}
library(Seurat)
library(SeuratData)
library(SeuratDisk)
library(SingleCellExperiment)
```


## Data

The dataset that we will work with, generated by Setty *et al.* 
includes **bone marrow stem/progenitor CD34+ cells** from **healthy donors**, 
sequenced using the Chromium Single Cell 3' Library preparation
kit. Although the full dataset includes cells from three donors, we will focus
on **replicate 1** (male, age 35).

All data and data-related files will be avaiable under the following directory:

```{r, "Set data Input directory", eval=T}
data_dir <- c("HandsOn3_SingleCell_Data_QC/")
```


## Getting help with R

All R programming is based on **functions**, each of which have their own
arguments and inputs. If you are ever doubtful as to how to use a function,
you may access function documentation using the `?` operator. 

For instance, you may look at the usage of the `Read10X()` function from
the `Seurat` R package, which will be used in the next section to load our 
single-cell expression matrix into R:

```{r, "Show 10x function usability",eval=T}
?Read10X
```


## Data loading and object creation

There are two main families of R packages for single-cell data analyses, each of
which use a different class of object to store and interact with the data:

- The **Seurat** analysis toolkit uses the `SeuratObject` class.
- Packages like **scater** and **scran** use the `SingleCellExperiment` class.

While this course is mainly based on `Seurat` for single-cell data analysis, 
it is good to be familiar with both types of objects, as there are interesting
packages and analyses outside the Seurat environment.

### SeuratObject

Single-cell data can be provided in a number of formats, one of which is the
**sparse matrix format**. These can be read into R using the Seurat function 
mentioned above and supplying the path to the directory containing the files:

```{r, "Loading Replicate-1 Counts", eval=T}
setty_rep1_matrix <- Read10X("setty_rep1/")
```

The expression matrix is loaded as a `dgCMatrix` object, which is a compressed
matrix format that saves space by only reporting non-zero elements:

```{r, "Show class of dgCMatrix", eval=T}
class(setty_rep1_matrix)

head(setty_rep1_matrix[c(1:10),c(1:10)])
```

Note that the matrix is still formatted as usual: with columns being cell IDs
(typically encoded as cell barcode sequences) and rows representing genes:

```{r, "Show rows and columns of dgCMatrix", eval=T}
head(colnames(setty_rep1_matrix))
head(rownames(setty_rep1_matrix))
```

We can use this matrix to create a `SeuratObject` to store expression as well as
other metrics and metadata. We will use the `CreateSeuratObject()` function, setting
`min.cells = 1` to only include genes that are expressed in at least one cell.
You may read more about this function accessing the help page (`?CreateSeuratObject`).

```{r, "Create Seurat Obejct", eval=T}
setty_seurat <- CreateSeuratObject(setty_rep1_matrix,
                                   project = "healthyBM",
                                   min.cells = 1)
setty_seurat
```

Observe that the dataset contains 39306 genes (i.e. features) and 6998 cells (i.e. samples).
The `SeuratObject` only contains one assay, named "RNA". If more modalities or other
data types were supplied, they would be stored as additional assays in the same `SeuratObject`.

The `SeuratObject` includes multiple slots where different types of information can be stored.
The `@` operator opens up the different slots in the object, including the `assays` slot, where
the "RNA" assay is contained. Inside it, there other slots featuring assay-specific information.
Here's how the hierarchy works:

```{r, "Showing S4 hierarchy",eval=T}
setty_seurat@assays

setty_seurat@assays$RNA

head(setty_seurat@assays$RNA@counts[c(1:10),c(1:10)])
```

The object also contains cell-level information, known as **metadata**, 
which can be accessed as follows:

```{r, "Show Cell Metadata",eval=T}
head(setty_seurat[[]])
```

These statistics are calculated by default upon `SeuratObject` creation, 
but more columns will be added to this table as we perform additional analyses.


### SingleCellExperiment

The loaded `dgCMatrix` object can be made into a `SingleCellExperiment` object using
the `SingleCellExperiment()` function. In this case, we will supply a `list` object
in which every element will be one assay. This allows us to set assay names:

```{r, "Load as SCE",eval=T}
setty_sce <- SingleCellExperiment(list(RNA=setty_rep1_matrix))

class(setty_sce)

setty_sce
```

While the formatting is different, you can see that the same logic as with the
`SeuratObject` class applies: there are multiple assays and different slots designed
to store information related to the single-cell dataset. There is additional information
regarding how to operate using this class in the [SingleCellExperiment package documentation](https://bioconductor.org/packages/devel/bioc/vignettes/SingleCellExperiment/inst/doc/intro.html).

### Interoperability between formats

Note that, to allow compatibility between different Bioconductor analysis packages, 
the `Seurat` package includes functions to convert to and from `SingleCellExperiment` 
objects.

For example, the same SCE object can be generated using the `SeuratObject` 
we had already created:

```{r, "seurat object to SCE", eval=T}
setty_sce <- as.SingleCellExperiment(setty_seurat)

setty_sce
```

The function makes a more complete SCE object, including both `counts` and `logcounts` assays,
as well as the same cell-level metadata that we found in the `SeuratObject` after creation.

Similarly, a `SingleCellExperiment` object can be converted to a `SeuratObject`:

```{r, "SCE to Seurat", eval=T}
setty_seurat <- as.Seurat(setty_sce)

setty_seurat
```


### Loading a reduced version of the dataset

In order for this tutorial to run smoothly, we have supplied a reduced version of
the Setty *et al.* dataset featuring a random selection of **3K cells**, instead of 
the ~7K in the original expression matrix. This will prevent memory issues and 
will allow you to run the analyses in a shorter time span.

The reduced dataset is stored as a *h5seurat* file, which is a file format designed
to store `SeuratObjects` in an efficient manner. It can be loaded using the 
`LoadH5Seurat()` function:

```{r, "Load Seurat Object from H5",eval=T}
setty_seurat <- LoadH5Seurat("data_preparation/setty_seurat.h5seurat")
```

Note that creating an object with the same name will **overwrite** the previous
`SeuratObject`. Even though we are doing it on purpose in this case, remember to
check for it when you are running your own analyses in R to prevent data loss!

Finally, you may remove unnecessary objects from your R session to free memory 
before you continue:

```{r, "Removed SCE and dgC",eval=T}
rm(setty_sce, setty_rep1_matrix)
```

---

## Exploratory analysis: Principal Component Analysis (PCA)

The high number of genes and cells in a single-cell expression matrix makes it
difficult to apply visualization techniques that can summarize the trends and
structure of the data at hand. **Dimensionality reduction** is often employed
to make this task easier. Among these methods, **Principal Component Analysis (PCA)** 
is the most commonly used, mainly due to its high interpretability. This makes
it a powerful tool for exploratory analysis and to identify biases in the data.

To run PCA, we first need to **scale the data** to eliminate biases. While this can
be done using other functions, we will use the `ScaleData()` function in Seurat, 
which does the following:

- Shifts the expression of each gene, so that the mean expression across cells is 0.
- Scales the expression of each gene, so that the variance across cells is 1. 

This step gives equal weight in downstream analyses, so that highly-expressed genes do not dominate.
The results of this are stored in `setty_seurat[["RNA"]]@scale.data`. We will run the scaling
for all genes in the data:

```{r, "Run Scaling", eval=T}
# select all gene names
all_genes <- rownames(setty_seurat)

# scale data
setty_seurat <- ScaleData(setty_seurat, features = all_genes)

# view the first 4 rows and columns of the resulting matrix
setty_seurat[["RNA"]]@scale.data[1:4, 1:4]
```

Now, we can perform linear dimension reduction using the `RunPCA()` function in Seurat:

```{r,"PCA",eval=T, warning =FALSE}
setty_seurat <- RunPCA(setty_seurat, 
                       features = all_genes,
                       verbose = FALSE)
```

Results will be stored in the `setty_seurat@reductions` slot:

```{r, "Show Reduction", eval=T}
setty_seurat

setty_seurat@reductions
```

To plot PCA, we will use the `DimPlot()` function. This function can be used 
to plot any reduced dimension representation of the data, so we will need to specify
which one we wish to plot:

```{r, "dimplot for pca",eval=T}
DimPlot(setty_seurat, reduction = "pca")
```

Since we have not yet normalized our data, cells are not properly clustered into
groups -quite contrarily, they appear together and spread across the diagonal between 
PC1 and PC2, suggesting that there are some sources of unwanted variation that we will 
need to remove before we continue.

---

## Quality control

### Cell quality control

Seurat allows you to easily explore QC metrics and filter cells based on any 
user-defined criteria. The number of genes and counts per cell, which are standard
metrics in the field, are already computed by Seurat and stored in the metadata slot:

```{r, "View MetaData", eval=T}
head(setty_seurat[[]])
```

To add to this, we will compute the percentage of reads mapping to mitochondrial 
genes using the `PercentageFeatureSet()` function. We will add this information to a new
column called `percent.mt` using the `[[` operator, which adds columns to metadata. 
All mitochondrial gene IDs start with "MT", which makes it easy to select the 
genes of interest:

```{r, "Add mitochondrial gene count", eval=T}
setty_seurat[["percent.mt"]] <- PercentageFeatureSet(setty_seurat, 
                                                     pattern = "^MT-")
```

We can visualize several QC metrics using the `VlnPlot()` function:

```{r, "Show Violoin",eval=T}
VlnPlot(setty_seurat, 
        features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), 
        ncol = 3)
```

We can see that there are a few outlier cells with high numbers of counts/genes and 
high mitochondrial gene counts. 

To better understand the relationship between the QC metrics, the `FeatureScatter()` 
function can be used to visualize feature-feature relationships. We will plot the metrics
to find thresholds for data filtering:

```{r, "shiw Feature Scatter", eval=T}
FeatureScatter(setty_seurat, feature1 = "nCount_RNA", feature2 = "percent.mt")
FeatureScatter(setty_seurat, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
```

Observe the following trends in these plots:
- **nCount_RNA vs percent.mt**: there are a number of cells for which the % 
of mitochondrial counts is high, whereas the number of total counts is low. 
These are likely to be dying cells.
- **nCount_RNA vs nFeature_RNA**: some cells show a high number of counts as 
well as a high number of features (genes). These are likely to be doublets.

Based on the QC plots, we will filter cells with >10% mitochondrial counts 
and >6000 and <500 genes. This can be achieved using the `subset()` function in Seurat:

```{r, "Use of subset", eval=T}
setty_seurat <- subset(setty_seurat, 
                      subset = nFeature_RNA > 500 & 
                      nFeature_RNA < 6000 &
                      percent.mt < 10)

setty_seurat
```

As a result, we are left with **2864 high-quality cells** for downstream analysis.

### Feature quality control

Feature QC is not included in the standard Seurat pipeline -instead, the tool is
designed to preserve all genes in the expression matrix, filtering them only upon
`SeuratObject` creation, as was demonstrated before. However, it is often better to
to remove genes after cell QC, given that the main filtering criteria is the frequency
of non-zero expression across the dataset. 

We will calculate the percentage of cells in which is gene is expressed to determine
whether the genes should remain in the dataset. To do this, we will need to extract
the count matrix from the `SeuratObject`:

```{r, "gene metadata", eval=T}
counts <- GetAssayData(setty_seurat,
                       assay = "RNA", slot = "counts")

total_expr <- rowSums(counts > 0)

head(total_expr)
```

Briefly, `counts>0` returns a matrix where each entry is `TRUE/FALSE` if that 
entry of the counts matrix exceeds 0. Performing `rowSums()` on that matrix gives
the total # of cells in which expression is non-zero for each gene.

We will keep genes that are expressed in **at least 3 cells**, which constitutes 1% of
our current dataset. We will filter the `total_expr` vector and use the `names()` function
to extract the IDs of our genes of interest:

```{r, "remove lowly expressed genes",eval=T}
keep_genes <- names(total_expr[total_expr > 3])

length(keep_genes)

head(keep_genes)
```

The `subset()` function we used above can filter genes based on a list of IDs 
supplied to the `features` argument:

```{r, "Actual Subset", eval=T}
setty_seurat <- subset(setty_seurat, 
                       features = keep_genes)

setty_seurat
```

As a result, **26551 genes** remain in the dataset.

---

## Normalization and feature selection

### Normalization

After removing unwanted cells from the dataset, the next step is to normalize the data. 
By default, Seurat employs a global-scaling normalization method, “LogNormalize”. This method
normalizes the feature expression measurements for each cell by the total expression, 
multiplies this by a scale factor (10,000 by default), and log-transforms the result. 
While there are other, more complex normalization strategies, this will suffice to remove
library size biases from our data.

Normalized values are stored in `setty_seurat[["RNA"]]@data`, whereas the raw expression
matrix is preserved in the `setty_seurat[["RNA"]]@counts` slot.

```{r, "Log normalize", eval=T}
setty_seurat <- NormalizeData(setty_seurat, 
                             normalization.method = "LogNormalize")

setty_seurat[["RNA"]]@data[1:4, 1:4]
```


### Feature selection

Next, we will calculate a subset of features that exhibit high cell-to-cell 
variation in the dataset (i.e, they are highly expressed in some cells, and 
lowly expressed in others). It has been described that focusing on these genes 
in downstream analysis helps to highlight biological signal in single-cell datasets.

In Seurat, this is done using the `FindVariableFeatures()` function, which stores
results in the `setty_seurat[["RNA"]]@var.features` slot:

```{r, "Find hihly varibale genes", eval=T}
setty_seurat <- FindVariableFeatures(setty_seurat)

# view top 10
head(setty_seurat[["RNA"]]@var.features, n = 10)
```

Seurat also includes a function, `VariableFeaturePlot()` to plot variable features 
in order to better understand their properties:

```{r, "Plot varibale features",eval=T}
VariableFeaturePlot(setty_seurat)
```

These features will be used in downstream analysis, including PCA. We run a previous
PCA with all genes for exploratory purposes, however, it is generally more efficient 
to select a set of highly variable features, as they capture the majority of data 
variation. Note that data will need to be **re-scaled** using the **normalized counts** 
instead of the raw counts:

```{r, "Rescaling", eval=T}
setty_seurat <- ScaleData(setty_seurat, 
                          features = all_genes)

setty_seurat <- RunPCA(setty_seurat, 
                       features = VariableFeatures(setty_seurat),
                       verbose = FALSE)

DimPlot(setty_seurat)
```

## Cell cycle scoring

In addition to normalization, we may want to eliminate other effects that may interfere
with data analysis. Among them, the cell cycle phase of each cell is known to be
a major source of variation in single-cell data.

To do this, each cell is assigned a **score** based on its expression of G2/M and S phase
markers. These markers must be known previously and supplied by the user. Luckily, Seurat
provides a list of genes for each phase in the `cc.genes.updated.2019` object, which is
loaded together with the package:

```{r, "Load cell cycle genes", eval=T}
cc.genes.updated.2019
```

Scores can be assigned in Seurat using the `CellCycleScoring()` function, which stores 
S and G2/M scores in `SeuratObject` meta data, along with the predicted classification 
of each cell in either G2M, S or G1 phase:

```{r, "Bifurcate genes", eval=T}
s_genes <- cc.genes.updated.2019$s.genes
g2m_genes <- cc.genes.updated.2019$s.genes

setty_seurat <- CellCycleScoring(setty_seurat, 
                                 s.features = s_genes,
                                 g2m.features = g2m_genes)

head(setty_seurat[[]])
```

Running a PCA using only the S and G2/M phase genes (instead of the highly variable 
genes, as we did before) reveals the extent to which the data is affected by this
source of variability:

```{r, "Dim plot of cell cycle genes", eval=T, warning = FALSE}
setty_seurat <- RunPCA(setty_seurat, 
                       features = c(s_genes, g2m_genes),
                       verbose = FALSE)
DimPlot(setty_seurat, group.by = "Phase")
```

In this PCA plot, we observe that the cells are clearly separated by cell cycle 
phase, particularly along PC1, which spreads S and G1 cells. This signal can be
removed from the data using the `ScaleData()` function, supplying cell cycle scores
to the `vars.to.regress` argument:

```{r,,"Regress cell cycle effects", eval=T, eval = FALSE}
setty_seurat <- ScaleData(setty_seurat, 
                          vars.to.regress = c("S.Score", "G2M.Score"),
                          features = all_genes)
```

Since this steps takes a long time to run, we will instead load a `SeuratObject`
that contains the pre-computed results of the cell cycle correction:

```{r, "Load cell cycle corrected data", eval=T}
setty_seurat <- LoadH5Seurat("processed_data/setty_seurat_cc-regressed.h5seurat")
```

The corrected counts are stored in the `setty_seurat[["RNA"]]@scale.data` slot. 

The PCA plot now reveals that the cell cycle effect observed on the cell cycle-associated 
genes no longer exists:

```{r, "Recheck cell cycle genes",eval=T, warning = FALSE}
setty_seurat <- RunPCA(setty_seurat, 
                       features = c(s_genes, g2m_genes),
                       verbose = FALSE)

DimPlot(setty_seurat, group.by = "Phase")
```

Observe how the PCA comptued with `VariableFeatures()` also reflects this, with 
cells not being separated by cell cycle phase.

```{r, "Variable features without cell cycle effects", eval=T}
setty_seurat <- RunPCA(setty_seurat, 
                       features = VariableFeatures(setty_seurat),
                       verbose = FALSE)

DimPlot(setty_seurat, group.by = "Phase")
```

---

## Cell clustering

### Determining the dimensionality of the data

To overcome the extensive technical noise in any single feature for scRNA-seq data, 
Seurat clusters cells based on PCA results. The top principal components represent 
the majority of the variation in the data, and therefore constitute a robust 
compression of the dataset. However, how many components should we choose to include?

A common method to select the number of relevant PCs is ranking them based on the 
percentage of variance explained by each one, which is known as an **elbow plot**
and can be generated by Seurat using the `ElbowPlot()` function:

```{r,"Show elbow plot", eval=T}
ElbowPlot(setty_seurat)
```

The "elbow" will be the point in the plot where the percentage of explained variance
starts to flatten, and in which the majority of the signal in the data will already be
captured. In this case, the elbow seems to be situated around 6 PCs, but anything up to 
10 PCs might be a good choice, since there is a slight plateau after PC 6. We will select 
**10 PCs** for clustering.

### Clustering the cells

To find cell clusters, Seurat first computes the "distances" (i.e. the similarity)
among cells in the dataset using the `FindNeighbors()` function and the number of
selected PCs, supplied to the `dims` argument. Then, groups of cells that lay 
very close together are detected using the `FindClusters()` function, which requires
users to define a `resolution` parameter. Higher resolution values will lead to
producing a larger number of clusters. For our 3K cell dataset, we will set a 
resolution value of 0.5:

```{r, "Clustering", eval=T}
setty_seurat <- FindNeighbors(setty_seurat, dims = 1:10)
setty_seurat <- FindClusters(setty_seurat, resolution = 0.5)
```

Seurat generated 11 cluters. The clusters can be found using the `Idents()` 
function, however, identities are also stored in the `seurat_clusters` column 
of the metadata table:

```{r, "View clusters", eval=T}
head(Idents(setty_seurat))

table(setty_seurat$seurat_clusters)
```

Let's see how these clusters are distributed in the PCA plot, 

```{r, eval=T}
DimPlot(setty_seurat, 
        reduction = "pca",
        group.by = "seurat_clusters",
        label = TRUE)
```

We observe that we generated several large groups that are clearly different from each
other, while some of the smaller clusters are more similar, e.g. clusters 0 and 3. 
There are also some groups that may not be as clearly defined, such as cluster 8. 
This type of plot may serve to inform the clustering and re-run it with more 
appropriate parameters, such as different number of PCs, smaller/larger resolution, etc.

We can also generate a tSNE plot of the clustered cells using the PCs that we used
for clustering:

```{r, "View t-SNE",eval=T}
setty_seurat <- RunTSNE(setty_seurat, 
                        dims = 1:10)

DimPlot(setty_seurat, 
        reduction = "tsne",
        label = TRUE)
```

**NOTE**: distances between clusters in the tSNE plot do not represent the real
similarity between the clusters.

### Clustering quality control

Although the groups seem fairly well-defined, it is always interesting to run some
quality control analyses to verify that we have correctly clustered the data.

One good way to see whether unwanted factors are influencing the clustering is
to check the distribution of QC metrics, such as the number of reads, genes and 
the proportion of mitochondrial expression. Some of the trends might be biological,
but others could be coming from the noise in the data, and it is good to be aware
of them in downstream analysis.

```{r, "QC measure", eval=T}
VlnPlot(setty_seurat, features = "nCount_RNA")

VlnPlot(setty_seurat, features = "nFeature_RNA")

VlnPlot(setty_seurat, features = "percent.mt")

VlnPlot(setty_seurat, features = "S.Score")

VlnPlot(setty_seurat, features = "G2M.Score")
```

## Save data for hands-on session 4

```{r, "Save data for hands on session 4", eval=T}
# remove unnecessary objects
rm(counts, g2m_genes, s_genes, keep_genes, all_genes, total_expr)

# save seurat object with clustering results
SaveH5Seurat(setty_seurat,
             filename = "processed_data/setty_seurat_clustered.h5seurat", overwrite = T)
```

---